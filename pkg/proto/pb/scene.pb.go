// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scene.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReqSceneEnter struct {
	SceneId              int64    `protobuf:"fixed64,1,opt,name=SceneId,proto3" json:"SceneId,omitempty"`
	Type                 int32    `protobuf:"fixed32,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Bytes                []byte   `protobuf:"bytes,3,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneEnter) Reset()         { *m = ReqSceneEnter{} }
func (m *ReqSceneEnter) String() string { return proto.CompactTextString(m) }
func (*ReqSceneEnter) ProtoMessage()    {}
func (*ReqSceneEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{0}
}
func (m *ReqSceneEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneEnter.Merge(m, src)
}
func (m *ReqSceneEnter) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneEnter.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneEnter proto.InternalMessageInfo

func (m *ReqSceneEnter) GetSceneId() int64 {
	if m != nil {
		return m.SceneId
	}
	return 0
}

func (m *ReqSceneEnter) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ReqSceneEnter) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type ResSceneEnter struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneEnter) Reset()         { *m = ResSceneEnter{} }
func (m *ResSceneEnter) String() string { return proto.CompactTextString(m) }
func (*ResSceneEnter) ProtoMessage()    {}
func (*ResSceneEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{1}
}
func (m *ResSceneEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneEnter.Merge(m, src)
}
func (m *ResSceneEnter) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneEnter.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneEnter proto.InternalMessageInfo

type NtcSceneEnter struct {
	SceneType            int32    `protobuf:"varint,1,opt,name=SceneType,proto3" json:"SceneType,omitempty"`
	SceneId              int64    `protobuf:"fixed64,2,opt,name=SceneId,proto3" json:"SceneId,omitempty"`
	PosX                 float32  `protobuf:"fixed32,3,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32  `protobuf:"fixed32,4,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32  `protobuf:"fixed32,5,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NtcSceneEnter) Reset()         { *m = NtcSceneEnter{} }
func (m *NtcSceneEnter) String() string { return proto.CompactTextString(m) }
func (*NtcSceneEnter) ProtoMessage()    {}
func (*NtcSceneEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{2}
}
func (m *NtcSceneEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneEnter.Merge(m, src)
}
func (m *NtcSceneEnter) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneEnter.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneEnter proto.InternalMessageInfo

func (m *NtcSceneEnter) GetSceneType() int32 {
	if m != nil {
		return m.SceneType
	}
	return 0
}

func (m *NtcSceneEnter) GetSceneId() int64 {
	if m != nil {
		return m.SceneId
	}
	return 0
}

func (m *NtcSceneEnter) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *NtcSceneEnter) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *NtcSceneEnter) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

type ReqSceneExit struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneExit) Reset()         { *m = ReqSceneExit{} }
func (m *ReqSceneExit) String() string { return proto.CompactTextString(m) }
func (*ReqSceneExit) ProtoMessage()    {}
func (*ReqSceneExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{3}
}
func (m *ReqSceneExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneExit.Merge(m, src)
}
func (m *ReqSceneExit) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneExit) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneExit.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneExit proto.InternalMessageInfo

type ResSceneExit struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneExit) Reset()         { *m = ResSceneExit{} }
func (m *ResSceneExit) String() string { return proto.CompactTextString(m) }
func (*ResSceneExit) ProtoMessage()    {}
func (*ResSceneExit) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{4}
}
func (m *ResSceneExit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneExit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneExit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneExit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneExit.Merge(m, src)
}
func (m *ResSceneExit) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneExit) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneExit.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneExit proto.InternalMessageInfo

type ReqSceneChangePos struct {
	PosX                 float32  `protobuf:"fixed32,1,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32  `protobuf:"fixed32,2,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32  `protobuf:"fixed32,3,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneChangePos) Reset()         { *m = ReqSceneChangePos{} }
func (m *ReqSceneChangePos) String() string { return proto.CompactTextString(m) }
func (*ReqSceneChangePos) ProtoMessage()    {}
func (*ReqSceneChangePos) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{5}
}
func (m *ReqSceneChangePos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneChangePos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneChangePos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneChangePos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneChangePos.Merge(m, src)
}
func (m *ReqSceneChangePos) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneChangePos) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneChangePos.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneChangePos proto.InternalMessageInfo

func (m *ReqSceneChangePos) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *ReqSceneChangePos) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *ReqSceneChangePos) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

type ResSceneChangePos struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneChangePos) Reset()         { *m = ResSceneChangePos{} }
func (m *ResSceneChangePos) String() string { return proto.CompactTextString(m) }
func (*ResSceneChangePos) ProtoMessage()    {}
func (*ResSceneChangePos) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{6}
}
func (m *ResSceneChangePos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneChangePos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneChangePos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneChangePos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneChangePos.Merge(m, src)
}
func (m *ResSceneChangePos) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneChangePos) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneChangePos.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneChangePos proto.InternalMessageInfo

type NtcSceneChangePos struct {
	Id                   int64    `protobuf:"fixed64,1,opt,name=Id,proto3" json:"Id,omitempty"`
	PosX                 float32  `protobuf:"fixed32,2,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32  `protobuf:"fixed32,3,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32  `protobuf:"fixed32,4,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NtcSceneChangePos) Reset()         { *m = NtcSceneChangePos{} }
func (m *NtcSceneChangePos) String() string { return proto.CompactTextString(m) }
func (*NtcSceneChangePos) ProtoMessage()    {}
func (*NtcSceneChangePos) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{7}
}
func (m *NtcSceneChangePos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneChangePos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneChangePos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneChangePos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneChangePos.Merge(m, src)
}
func (m *NtcSceneChangePos) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneChangePos) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneChangePos.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneChangePos proto.InternalMessageInfo

func (m *NtcSceneChangePos) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NtcSceneChangePos) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *NtcSceneChangePos) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *NtcSceneChangePos) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

type NtcSceneVisible struct {
	Id                   int64            `protobuf:"fixed64,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Type                 int32            `protobuf:"fixed32,2,opt,name=Type,proto3" json:"Type,omitempty"`
	PosX                 float32          `protobuf:"fixed32,3,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32          `protobuf:"fixed32,4,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32          `protobuf:"fixed32,5,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	ForX                 float32          `protobuf:"fixed32,6,opt,name=ForX,proto3" json:"ForX,omitempty"`
	ForY                 float32          `protobuf:"fixed32,7,opt,name=ForY,proto3" json:"ForY,omitempty"`
	ForZ                 float32          `protobuf:"fixed32,8,opt,name=ForZ,proto3" json:"ForZ,omitempty"`
	IntInfo              map[int32]int32  `protobuf:"bytes,9,rep,name=IntInfo,proto3" json:"IntInfo,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	LongInfo             map[int32]int64  `protobuf:"bytes,10,rep,name=LongInfo,proto3" json:"LongInfo,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	IStrInfo             map[int32]string `protobuf:"bytes,11,rep,name=IStrInfo,proto3" json:"IStrInfo,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NtcSceneVisible) Reset()         { *m = NtcSceneVisible{} }
func (m *NtcSceneVisible) String() string { return proto.CompactTextString(m) }
func (*NtcSceneVisible) ProtoMessage()    {}
func (*NtcSceneVisible) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{8}
}
func (m *NtcSceneVisible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneVisible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneVisible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneVisible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneVisible.Merge(m, src)
}
func (m *NtcSceneVisible) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneVisible) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneVisible.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneVisible proto.InternalMessageInfo

func (m *NtcSceneVisible) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NtcSceneVisible) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *NtcSceneVisible) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *NtcSceneVisible) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *NtcSceneVisible) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

func (m *NtcSceneVisible) GetForX() float32 {
	if m != nil {
		return m.ForX
	}
	return 0
}

func (m *NtcSceneVisible) GetForY() float32 {
	if m != nil {
		return m.ForY
	}
	return 0
}

func (m *NtcSceneVisible) GetForZ() float32 {
	if m != nil {
		return m.ForZ
	}
	return 0
}

func (m *NtcSceneVisible) GetIntInfo() map[int32]int32 {
	if m != nil {
		return m.IntInfo
	}
	return nil
}

func (m *NtcSceneVisible) GetLongInfo() map[int32]int64 {
	if m != nil {
		return m.LongInfo
	}
	return nil
}

func (m *NtcSceneVisible) GetIStrInfo() map[int32]string {
	if m != nil {
		return m.IStrInfo
	}
	return nil
}

type NtcSceneInvisible struct {
	Id                   int64    `protobuf:"fixed64,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NtcSceneInvisible) Reset()         { *m = NtcSceneInvisible{} }
func (m *NtcSceneInvisible) String() string { return proto.CompactTextString(m) }
func (*NtcSceneInvisible) ProtoMessage()    {}
func (*NtcSceneInvisible) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{9}
}
func (m *NtcSceneInvisible) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneInvisible) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneInvisible.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneInvisible) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneInvisible.Merge(m, src)
}
func (m *NtcSceneInvisible) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneInvisible) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneInvisible.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneInvisible proto.InternalMessageInfo

func (m *NtcSceneInvisible) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ReqSceneMoveStart struct {
	ForX                 float32  `protobuf:"fixed32,1,opt,name=ForX,proto3" json:"ForX,omitempty"`
	ForY                 float32  `protobuf:"fixed32,2,opt,name=ForY,proto3" json:"ForY,omitempty"`
	ForZ                 float32  `protobuf:"fixed32,3,opt,name=ForZ,proto3" json:"ForZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneMoveStart) Reset()         { *m = ReqSceneMoveStart{} }
func (m *ReqSceneMoveStart) String() string { return proto.CompactTextString(m) }
func (*ReqSceneMoveStart) ProtoMessage()    {}
func (*ReqSceneMoveStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{10}
}
func (m *ReqSceneMoveStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneMoveStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneMoveStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneMoveStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneMoveStart.Merge(m, src)
}
func (m *ReqSceneMoveStart) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneMoveStart) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneMoveStart.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneMoveStart proto.InternalMessageInfo

func (m *ReqSceneMoveStart) GetForX() float32 {
	if m != nil {
		return m.ForX
	}
	return 0
}

func (m *ReqSceneMoveStart) GetForY() float32 {
	if m != nil {
		return m.ForY
	}
	return 0
}

func (m *ReqSceneMoveStart) GetForZ() float32 {
	if m != nil {
		return m.ForZ
	}
	return 0
}

type ResSceneMoveStart struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneMoveStart) Reset()         { *m = ResSceneMoveStart{} }
func (m *ResSceneMoveStart) String() string { return proto.CompactTextString(m) }
func (*ResSceneMoveStart) ProtoMessage()    {}
func (*ResSceneMoveStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{11}
}
func (m *ResSceneMoveStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneMoveStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneMoveStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneMoveStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneMoveStart.Merge(m, src)
}
func (m *ResSceneMoveStart) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneMoveStart) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneMoveStart.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneMoveStart proto.InternalMessageInfo

type NtcSceneMoveStart struct {
	Id                   int64    `protobuf:"fixed64,1,opt,name=Id,proto3" json:"Id,omitempty"`
	PosX                 float32  `protobuf:"fixed32,2,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32  `protobuf:"fixed32,3,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32  `protobuf:"fixed32,4,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	ForX                 float32  `protobuf:"fixed32,5,opt,name=ForX,proto3" json:"ForX,omitempty"`
	ForY                 float32  `protobuf:"fixed32,6,opt,name=ForY,proto3" json:"ForY,omitempty"`
	ForZ                 float32  `protobuf:"fixed32,7,opt,name=ForZ,proto3" json:"ForZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NtcSceneMoveStart) Reset()         { *m = NtcSceneMoveStart{} }
func (m *NtcSceneMoveStart) String() string { return proto.CompactTextString(m) }
func (*NtcSceneMoveStart) ProtoMessage()    {}
func (*NtcSceneMoveStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{12}
}
func (m *NtcSceneMoveStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneMoveStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneMoveStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneMoveStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneMoveStart.Merge(m, src)
}
func (m *NtcSceneMoveStart) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneMoveStart) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneMoveStart.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneMoveStart proto.InternalMessageInfo

func (m *NtcSceneMoveStart) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NtcSceneMoveStart) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *NtcSceneMoveStart) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *NtcSceneMoveStart) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

func (m *NtcSceneMoveStart) GetForX() float32 {
	if m != nil {
		return m.ForX
	}
	return 0
}

func (m *NtcSceneMoveStart) GetForY() float32 {
	if m != nil {
		return m.ForY
	}
	return 0
}

func (m *NtcSceneMoveStart) GetForZ() float32 {
	if m != nil {
		return m.ForZ
	}
	return 0
}

type ReqSceneMoveStop struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneMoveStop) Reset()         { *m = ReqSceneMoveStop{} }
func (m *ReqSceneMoveStop) String() string { return proto.CompactTextString(m) }
func (*ReqSceneMoveStop) ProtoMessage()    {}
func (*ReqSceneMoveStop) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{13}
}
func (m *ReqSceneMoveStop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneMoveStop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneMoveStop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneMoveStop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneMoveStop.Merge(m, src)
}
func (m *ReqSceneMoveStop) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneMoveStop) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneMoveStop.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneMoveStop proto.InternalMessageInfo

type ResSceneMoveStop struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneMoveStop) Reset()         { *m = ResSceneMoveStop{} }
func (m *ResSceneMoveStop) String() string { return proto.CompactTextString(m) }
func (*ResSceneMoveStop) ProtoMessage()    {}
func (*ResSceneMoveStop) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{14}
}
func (m *ResSceneMoveStop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneMoveStop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneMoveStop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneMoveStop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneMoveStop.Merge(m, src)
}
func (m *ResSceneMoveStop) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneMoveStop) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneMoveStop.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneMoveStop proto.InternalMessageInfo

type NtcSceneMoveStop struct {
	Id                   int64    `protobuf:"fixed64,1,opt,name=Id,proto3" json:"Id,omitempty"`
	PosX                 float32  `protobuf:"fixed32,2,opt,name=PosX,proto3" json:"PosX,omitempty"`
	PosY                 float32  `protobuf:"fixed32,3,opt,name=PosY,proto3" json:"PosY,omitempty"`
	PosZ                 float32  `protobuf:"fixed32,4,opt,name=PosZ,proto3" json:"PosZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NtcSceneMoveStop) Reset()         { *m = NtcSceneMoveStop{} }
func (m *NtcSceneMoveStop) String() string { return proto.CompactTextString(m) }
func (*NtcSceneMoveStop) ProtoMessage()    {}
func (*NtcSceneMoveStop) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{15}
}
func (m *NtcSceneMoveStop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NtcSceneMoveStop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NtcSceneMoveStop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NtcSceneMoveStop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NtcSceneMoveStop.Merge(m, src)
}
func (m *NtcSceneMoveStop) XXX_Size() int {
	return m.Size()
}
func (m *NtcSceneMoveStop) XXX_DiscardUnknown() {
	xxx_messageInfo_NtcSceneMoveStop.DiscardUnknown(m)
}

var xxx_messageInfo_NtcSceneMoveStop proto.InternalMessageInfo

func (m *NtcSceneMoveStop) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NtcSceneMoveStop) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *NtcSceneMoveStop) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *NtcSceneMoveStop) GetPosZ() float32 {
	if m != nil {
		return m.PosZ
	}
	return 0
}

type ReqSceneCreate struct {
	SceneType            int32    `protobuf:"fixed32,1,opt,name=SceneType,proto3" json:"SceneType,omitempty"`
	SceneId              int64    `protobuf:"fixed64,2,opt,name=SceneId,proto3" json:"SceneId,omitempty"`
	ActorCap             int64    `protobuf:"fixed64,3,opt,name=ActorCap,proto3" json:"ActorCap,omitempty"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneCreate) Reset()         { *m = ReqSceneCreate{} }
func (m *ReqSceneCreate) String() string { return proto.CompactTextString(m) }
func (*ReqSceneCreate) ProtoMessage()    {}
func (*ReqSceneCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{16}
}
func (m *ReqSceneCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneCreate.Merge(m, src)
}
func (m *ReqSceneCreate) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneCreate.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneCreate proto.InternalMessageInfo

func (m *ReqSceneCreate) GetSceneType() int32 {
	if m != nil {
		return m.SceneType
	}
	return 0
}

func (m *ReqSceneCreate) GetSceneId() int64 {
	if m != nil {
		return m.SceneId
	}
	return 0
}

func (m *ReqSceneCreate) GetActorCap() int64 {
	if m != nil {
		return m.ActorCap
	}
	return 0
}

func (m *ReqSceneCreate) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ResSceneCreate struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneCreate) Reset()         { *m = ResSceneCreate{} }
func (m *ResSceneCreate) String() string { return proto.CompactTextString(m) }
func (*ResSceneCreate) ProtoMessage()    {}
func (*ResSceneCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{17}
}
func (m *ResSceneCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneCreate.Merge(m, src)
}
func (m *ResSceneCreate) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneCreate.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneCreate proto.InternalMessageInfo

type ReqSceneDispose struct {
	SceneId              int64    `protobuf:"fixed64,1,opt,name=SceneId,proto3" json:"SceneId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqSceneDispose) Reset()         { *m = ReqSceneDispose{} }
func (m *ReqSceneDispose) String() string { return proto.CompactTextString(m) }
func (*ReqSceneDispose) ProtoMessage()    {}
func (*ReqSceneDispose) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{18}
}
func (m *ReqSceneDispose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqSceneDispose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqSceneDispose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqSceneDispose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqSceneDispose.Merge(m, src)
}
func (m *ReqSceneDispose) XXX_Size() int {
	return m.Size()
}
func (m *ReqSceneDispose) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqSceneDispose.DiscardUnknown(m)
}

var xxx_messageInfo_ReqSceneDispose proto.InternalMessageInfo

func (m *ReqSceneDispose) GetSceneId() int64 {
	if m != nil {
		return m.SceneId
	}
	return 0
}

type ResSceneDispose struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResSceneDispose) Reset()         { *m = ResSceneDispose{} }
func (m *ResSceneDispose) String() string { return proto.CompactTextString(m) }
func (*ResSceneDispose) ProtoMessage()    {}
func (*ResSceneDispose) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5bd834e1feb3b48, []int{19}
}
func (m *ResSceneDispose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResSceneDispose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResSceneDispose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResSceneDispose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResSceneDispose.Merge(m, src)
}
func (m *ResSceneDispose) XXX_Size() int {
	return m.Size()
}
func (m *ResSceneDispose) XXX_DiscardUnknown() {
	xxx_messageInfo_ResSceneDispose.DiscardUnknown(m)
}

var xxx_messageInfo_ResSceneDispose proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ReqSceneEnter)(nil), "pb.ReqSceneEnter")
	proto.RegisterType((*ResSceneEnter)(nil), "pb.ResSceneEnter")
	proto.RegisterType((*NtcSceneEnter)(nil), "pb.NtcSceneEnter")
	proto.RegisterType((*ReqSceneExit)(nil), "pb.ReqSceneExit")
	proto.RegisterType((*ResSceneExit)(nil), "pb.ResSceneExit")
	proto.RegisterType((*ReqSceneChangePos)(nil), "pb.ReqSceneChangePos")
	proto.RegisterType((*ResSceneChangePos)(nil), "pb.ResSceneChangePos")
	proto.RegisterType((*NtcSceneChangePos)(nil), "pb.NtcSceneChangePos")
	proto.RegisterType((*NtcSceneVisible)(nil), "pb.NtcSceneVisible")
	proto.RegisterMapType((map[int32]string)(nil), "pb.NtcSceneVisible.IStrInfoEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "pb.NtcSceneVisible.IntInfoEntry")
	proto.RegisterMapType((map[int32]int64)(nil), "pb.NtcSceneVisible.LongInfoEntry")
	proto.RegisterType((*NtcSceneInvisible)(nil), "pb.NtcSceneInvisible")
	proto.RegisterType((*ReqSceneMoveStart)(nil), "pb.ReqSceneMoveStart")
	proto.RegisterType((*ResSceneMoveStart)(nil), "pb.ResSceneMoveStart")
	proto.RegisterType((*NtcSceneMoveStart)(nil), "pb.NtcSceneMoveStart")
	proto.RegisterType((*ReqSceneMoveStop)(nil), "pb.ReqSceneMoveStop")
	proto.RegisterType((*ResSceneMoveStop)(nil), "pb.ResSceneMoveStop")
	proto.RegisterType((*NtcSceneMoveStop)(nil), "pb.NtcSceneMoveStop")
	proto.RegisterType((*ReqSceneCreate)(nil), "pb.ReqSceneCreate")
	proto.RegisterType((*ResSceneCreate)(nil), "pb.ResSceneCreate")
	proto.RegisterType((*ReqSceneDispose)(nil), "pb.ReqSceneDispose")
	proto.RegisterType((*ResSceneDispose)(nil), "pb.ResSceneDispose")
}

func init() { proto.RegisterFile("scene.proto", fileDescriptor_d5bd834e1feb3b48) }

var fileDescriptor_d5bd834e1feb3b48 = []byte{
	// 581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x8a, 0xd3, 0x40,
	0x14, 0x76, 0x92, 0xfe, 0x9e, 0xfe, 0x24, 0x8d, 0x0a, 0xa1, 0x48, 0xa9, 0xf1, 0xa6, 0x20, 0x54,
	0xd0, 0x1b, 0xa9, 0x78, 0xe1, 0xfe, 0x08, 0x05, 0x7f, 0x96, 0x54, 0x64, 0xdb, 0x0b, 0x25, 0xa9,
	0xe3, 0x5a, 0x5c, 0x32, 0x31, 0x33, 0x96, 0xed, 0xb5, 0x2f, 0x21, 0x88, 0xef, 0xe3, 0xa5, 0x8f,
	0x20, 0xf5, 0x45, 0x64, 0x26, 0xc9, 0x64, 0xb2, 0x9d, 0x65, 0x85, 0xdd, 0xbb, 0x39, 0x5f, 0xcf,
	0x77, 0xbe, 0x6f, 0xce, 0xe9, 0x99, 0x40, 0x8b, 0x2e, 0x71, 0x84, 0xc7, 0x71, 0x42, 0x18, 0x71,
	0x8c, 0x38, 0xf4, 0x66, 0xd0, 0xf1, 0xf1, 0x97, 0x19, 0x47, 0x0f, 0x23, 0x86, 0x13, 0xc7, 0x85,
	0xba, 0x88, 0xa6, 0x1f, 0x5c, 0x34, 0x44, 0x23, 0xdb, 0xcf, 0x43, 0xc7, 0x81, 0xca, 0x9b, 0x4d,
	0x8c, 0x5d, 0x63, 0x88, 0x46, 0x96, 0x2f, 0xce, 0xce, 0x2d, 0xa8, 0xee, 0x6d, 0x18, 0xa6, 0xae,
	0x39, 0x44, 0xa3, 0xb6, 0x9f, 0x06, 0x9e, 0xc5, 0x8b, 0xd2, 0xa2, 0xa8, 0xf7, 0x0d, 0x41, 0xe7,
	0x15, 0x5b, 0x2a, 0x32, 0x77, 0xa0, 0x29, 0x22, 0x51, 0x91, 0x0b, 0x55, 0xfd, 0x02, 0x50, 0x4d,
	0x18, 0x3b, 0x26, 0x8e, 0x08, 0x3d, 0x16, 0x7a, 0x86, 0x2f, 0xce, 0x19, 0x36, 0x77, 0x2b, 0x12,
	0x9b, 0x67, 0xd8, 0xc2, 0xad, 0x4a, 0x6c, 0xe1, 0x75, 0xa1, 0x2d, 0xef, 0x7a, 0xb6, 0x62, 0x69,
	0x4c, 0x8b, 0xf8, 0x35, 0xf4, 0xf2, 0xdf, 0xf7, 0x3f, 0x05, 0xd1, 0x09, 0x3e, 0x22, 0x54, 0x0a,
	0x22, 0x8d, 0xa0, 0xa1, 0x11, 0x34, 0x15, 0xc1, 0x9b, 0xbc, 0x20, 0x2d, 0x17, 0xf4, 0xde, 0x43,
	0x2f, 0x6f, 0x45, 0xa1, 0xd2, 0x05, 0x43, 0x36, 0xdc, 0x50, 0xae, 0x69, 0x68, 0x54, 0x4d, 0x8d,
	0x6a, 0x45, 0x51, 0xfd, 0x59, 0x01, 0x2b, 0x57, 0x78, 0xbb, 0xa2, 0xab, 0xf0, 0x14, 0xeb, 0xea,
	0xef, 0xcc, 0xf2, 0x0a, 0xad, 0xe5, 0xd8, 0x73, 0x92, 0x1c, 0xbb, 0xb5, 0x14, 0xe3, 0xe7, 0x0c,
	0x9b, 0xbb, 0x75, 0x89, 0xcd, 0x33, 0x6c, 0xe1, 0x36, 0x24, 0xb6, 0x70, 0x26, 0x50, 0x9f, 0x46,
	0x6c, 0x1a, 0x7d, 0x24, 0x6e, 0x73, 0x68, 0x8e, 0x5a, 0x0f, 0x87, 0xe3, 0x38, 0x1c, 0x9f, 0xbb,
	0xc1, 0x38, 0x4b, 0x39, 0x8c, 0x58, 0xb2, 0xf1, 0x73, 0x82, 0xf3, 0x14, 0x1a, 0x2f, 0x48, 0x74,
	0x22, 0xc8, 0x20, 0xc8, 0x77, 0x75, 0xe4, 0x3c, 0x27, 0x65, 0x4b, 0x0a, 0xa7, 0x4f, 0x67, 0x2c,
	0x11, 0xf4, 0xd6, 0xc5, 0xf4, 0x3c, 0x27, 0xa3, 0xe7, 0x61, 0x7f, 0x02, 0x6d, 0xd5, 0x96, 0x63,
	0x83, 0xf9, 0x19, 0x6f, 0x44, 0x9b, 0x2d, 0x9f, 0x1f, 0xf9, 0x7e, 0xac, 0x83, 0xd3, 0xaf, 0x79,
	0xa3, 0xd3, 0x60, 0x62, 0x3c, 0x46, 0xfd, 0x27, 0xd0, 0x29, 0xb9, 0xba, 0x8c, 0x6c, 0x9f, 0x23,
	0x97, 0x3c, 0x5d, 0x46, 0x6e, 0x2a, 0x64, 0xef, 0x5e, 0xf1, 0x07, 0x9c, 0x46, 0x6b, 0xfd, 0x1f,
	0x44, 0xdd, 0x85, 0x97, 0x64, 0x8d, 0x67, 0x2c, 0x48, 0x98, 0x9c, 0x32, 0xd2, 0x4c, 0xd9, 0xd0,
	0x4c, 0xd9, 0x2c, 0xa6, 0xac, 0xee, 0x82, 0x2c, 0xe8, 0xfd, 0x40, 0x85, 0x97, 0x42, 0xe6, 0x1a,
	0x97, 0x41, 0x5a, 0xae, 0x6a, 0x2c, 0xd7, 0x34, 0x96, 0xeb, 0x8a, 0x65, 0x07, 0xec, 0x72, 0x0f,
	0x48, 0x9c, 0x62, 0xb4, 0x8c, 0xbd, 0x03, 0xbb, 0x7c, 0x09, 0x12, 0x5f, 0xeb, 0x42, 0x9f, 0x41,
	0x57, 0xbe, 0x4b, 0x09, 0x0e, 0x18, 0xde, 0x7d, 0x3d, 0xad, 0xff, 0x7b, 0x3d, 0xfb, 0xd0, 0x78,
	0xb6, 0x64, 0x24, 0xd9, 0x0f, 0x62, 0xa1, 0x6a, 0xfb, 0x32, 0xe6, 0xca, 0x07, 0x01, 0x0b, 0x84,
	0x72, 0xdb, 0x17, 0x67, 0xcf, 0xe6, 0xca, 0x54, 0x51, 0xf6, 0xee, 0x83, 0x95, 0x7b, 0x39, 0x58,
	0xd1, 0x98, 0x50, 0x7c, 0xf1, 0x17, 0xc3, 0xeb, 0xf1, 0x64, 0xaa, 0x26, 0xef, 0xdd, 0xfe, 0xb5,
	0x1d, 0xa0, 0xdf, 0xdb, 0x01, 0xfa, 0xb3, 0x1d, 0xa0, 0xef, 0x7f, 0x07, 0x37, 0x16, 0xe6, 0x83,
	0x38, 0x0c, 0x6b, 0xe2, 0x8b, 0xf4, 0xe8, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xb1, 0x31,
	0xff, 0xa0, 0x06, 0x00, 0x00,
}

func (m *ReqSceneEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintScene(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Type))
		i--
		dAtA[i] = 0x15
	}
	if m.SceneId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SceneId))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x25
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0x1d
	}
	if m.SceneId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SceneId))
		i--
		dAtA[i] = 0x11
	}
	if m.SceneType != 0 {
		i = encodeVarintScene(dAtA, i, uint64(m.SceneType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneExit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneExit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneExit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneChangePos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneChangePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneChangePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x1d
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x15
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneChangePos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneChangePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneChangePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneChangePos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneChangePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneChangePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x25
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x1d
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0x15
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneVisible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneVisible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneVisible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IStrInfo) > 0 {
		for k := range m.IStrInfo {
			v := m.IStrInfo[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintScene(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintScene(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.LongInfo) > 0 {
		for k := range m.LongInfo {
			v := m.LongInfo[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintScene(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.IntInfo) > 0 {
		for k := range m.IntInfo {
			v := m.IntInfo[k]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintScene(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ForZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForZ))))
		i--
		dAtA[i] = 0x45
	}
	if m.ForY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForY))))
		i--
		dAtA[i] = 0x3d
	}
	if m.ForX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForX))))
		i--
		dAtA[i] = 0x35
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x25
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Type != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Type))
		i--
		dAtA[i] = 0x15
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneInvisible) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneInvisible) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneInvisible) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneMoveStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneMoveStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneMoveStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ForZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForZ))))
		i--
		dAtA[i] = 0x1d
	}
	if m.ForY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForY))))
		i--
		dAtA[i] = 0x15
	}
	if m.ForX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForX))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneMoveStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneMoveStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneMoveStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneMoveStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneMoveStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneMoveStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ForZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForZ))))
		i--
		dAtA[i] = 0x3d
	}
	if m.ForY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForY))))
		i--
		dAtA[i] = 0x35
	}
	if m.ForX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ForX))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x25
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x1d
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0x15
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneMoveStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneMoveStop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneMoveStop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneMoveStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneMoveStop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneMoveStop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NtcSceneMoveStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtcSceneMoveStop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NtcSceneMoveStop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PosZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosZ))))
		i--
		dAtA[i] = 0x25
	}
	if m.PosY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
		i--
		dAtA[i] = 0x1d
	}
	if m.PosX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
		i--
		dAtA[i] = 0x15
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintScene(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.ActorCap != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ActorCap))
		i--
		dAtA[i] = 0x19
	}
	if m.SceneId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SceneId))
		i--
		dAtA[i] = 0x11
	}
	if m.SceneType != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.SceneType))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReqSceneDispose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSceneDispose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqSceneDispose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SceneId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SceneId))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ResSceneDispose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResSceneDispose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResSceneDispose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintScene(dAtA []byte, offset int, v uint64) int {
	offset -= sovScene(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReqSceneEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneId != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 5
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneType != 0 {
		n += 1 + sovScene(uint64(m.SceneType))
	}
	if m.SceneId != 0 {
		n += 9
	}
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneExit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneChangePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneChangePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneChangePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneVisible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 5
	}
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.ForX != 0 {
		n += 5
	}
	if m.ForY != 0 {
		n += 5
	}
	if m.ForZ != 0 {
		n += 5
	}
	if len(m.IntInfo) > 0 {
		for k, v := range m.IntInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	if len(m.LongInfo) > 0 {
		for k, v := range m.LongInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 8
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	if len(m.IStrInfo) > 0 {
		for k, v := range m.IStrInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + len(v) + sovScene(uint64(len(v)))
			n += mapEntrySize + 1 + sovScene(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneInvisible) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneMoveStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForX != 0 {
		n += 5
	}
	if m.ForY != 0 {
		n += 5
	}
	if m.ForZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneMoveStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneMoveStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.ForX != 0 {
		n += 5
	}
	if m.ForY != 0 {
		n += 5
	}
	if m.ForZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneMoveStop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneMoveStop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NtcSceneMoveStop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.PosX != 0 {
		n += 5
	}
	if m.PosY != 0 {
		n += 5
	}
	if m.PosZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneType != 0 {
		n += 5
	}
	if m.SceneId != 0 {
		n += 9
	}
	if m.ActorCap != 0 {
		n += 9
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovScene(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSceneDispose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneId != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResSceneDispose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovScene(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScene(x uint64) (n int) {
	return sovScene(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReqSceneEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			m.SceneId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SceneId = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScene
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneType", wireType)
			}
			m.SceneType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			m.SceneId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SceneId = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneExit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneChangePos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneChangePos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneChangePos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneChangePos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneChangePos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneChangePos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneChangePos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneChangePos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneChangePos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneVisible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneVisible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneVisible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForX = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForY = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForZ = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScene
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntInfo == nil {
				m.IntInfo = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IntInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScene
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LongInfo == nil {
				m.LongInfo = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LongInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IStrInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScene
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IStrInfo == nil {
				m.IStrInfo = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScene
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScene
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthScene
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthScene
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScene(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthScene
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IStrInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneInvisible) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneInvisible: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneInvisible: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneMoveStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneMoveStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneMoveStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForX = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForY = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneMoveStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneMoveStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneMoveStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneMoveStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneMoveStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneMoveStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForX = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForY = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ForZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneMoveStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneMoveStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneMoveStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneMoveStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneMoveStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneMoveStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtcSceneMoveStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtcSceneMoveStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtcSceneMoveStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneType", wireType)
			}
			m.SceneType = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.SceneType = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			m.SceneId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SceneId = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorCap", wireType)
			}
			m.ActorCap = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ActorCap = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScene
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthScene
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthScene
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSceneDispose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSceneDispose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSceneDispose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			m.SceneId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SceneId = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResSceneDispose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScene
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResSceneDispose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResSceneDispose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipScene(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScene
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScene(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScene
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScene
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScene
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScene
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScene
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScene        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScene          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScene = fmt.Errorf("proto: unexpected end of group")
)
